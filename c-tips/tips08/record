C和指针(第二版)第11章:动态内存分配
todo https://linux.die.net/man/3/malloc

什么时候应该使用动态内存分配
    数组的长度常常在运行时才知道
    所需的内存空间取决于运行时的某些因素


怎样进行动态内存分配和回收
<stdlib.h>
void *malloc(size_t size);
void free(void *pointer);

malloc的参数是需要分配的内存字节数,返回一个指向被分配的内存块起始位置的指针或者NULL指针.
malloc分配的是一块连续内存,当内存池是空的或者无法满足分配要求时返回NULL.
需要对每个从malloc返回的指针都进行检查.

free的参数要么是NULL,要么是一个从前从malloc、calloc或realloc返回的值.
参数是NULL时,free不会产生任何效果.



void *calloc(size_t num_elements, size_t element_size);
void realloc(void *ptr, size_t new_size);

calloc的参数是元素的数量和每个元素的字节数
malloc和calloc之间的主要区别是后者在返回指向内存的指针之前把内存初始化为0.

realloc用于修改一个原先已经分配的内存块的大小,可以使一块内存扩大或缩小.
realloc如果用于缩小一个内存块,该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依然保留.
realloc如果用于扩大一个内存块,那么这块内存原先的内容依然保留,新增加的内存添加到原先内存块的后面，新内存并未以任何方法进行初始化;
       如果原先的内存块无法改变大小，并把原先那块内存的内容复制到新的块上.
       在使用realloc之后，就不能再使用指向旧内存的指针,而是应该改用realloc所返回的新指针.
realloc的第一参数是NULL时,行为和malloc一模一样.


常见的动态内存错误
第1大类:忘记检查所请求的内存是否分配成功
第2大类:操作内存时超出了分配内存的边界
对NULL指针进行解引用操作
释放并非动态分配的内存
试图释放一块动态分配的内存的一部分
一块动态内存被释放之后被继续使用
内存泄漏


关于内存释放:
当使用free时，可能出现各种不同的错误，传递给free的指针必须是一个从malloc/calloc/realloc函数返回的指针.
传递free函数一个指针，让它释放一块并非动态分配的内存可能导致程序立即终止或在晚些时候终止.
试图释放一块动态分配内存的一部分也有可能引起类似的问题
释放一块内存的一部分是不被允许的。动态分配的内存必须整块一起释放.
realloc函数可以缩小一块动态分配的内存，有效地释放尾部的部分内存.
常见场景:一块动态内存的指针拷贝散布于程序各处,某个地方进行释放,其他地方还在使用





